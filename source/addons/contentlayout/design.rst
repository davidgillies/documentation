
Creating a design
=================

First of all, you need to create an extension (please refer to
:ref:`creating-an-extension`). After you need to:

- enable Grok in your extension (:ref:`enable-grok-for-your-extension`),

- include ``silva.core.contentlayout`` as a dependency in the
  ``configure.zcml`` of your extension.

After you will be able to add a design and define slots for it. You
can finish by adding restrictions to either your design or your slots.

Adding a design
---------------

To create a new design, you need to define a new Python class, inside
an existing Python module of your extension:

.. sourcecode:: python
   :linenos:

   from silva.core.contentlayout import Design, Slot
   from five import grok

   class MyDesign(Design):
      grok.name('my_design')
      grok.title('My Design')

      def update(self):
          self.title = self.context.get_title_or_id()


- On line 4, we define the new design by inheriting from the
  ``silva.core.contentlayout.Design`` class (see
  :py:interface:`~silva.core.contentlayout.interfaces.IDesign` for
  more information).

- On line 5, we give a unique identifier to the design with the help
  of the :py:func:`grok.name` directive. This identifier will be used
  to identify uniquely the design within Silva. This will let you keep
  the possibility to rename or move the design class without breaking
  existing content using this design.

- On line 6, we give with :py:func:`grok.title` a user-friendly name
  to the design, that will be used in the :term:`SMI`.

In addition to the design class, a design template must be
created. This template will be a `Chameleon Page Template`_, with the
extension ``.upt``, and will be associated to the design following the
regular Grok rules: the template filename must have the same name than
your design class in lower case, and be located inside a directory
called the name of your Python module where the design class is
defined, plus ``_templates``. For example, if yor design class is
located inside a Python module called ``mydesign.py``, you will create
a directory called ``mydesign_templates`` next to it, and add your
template inside this directory as ``mydesign.upt``.

The design template will follow the regular `Chameleon Page
Template`_, and its namespace will provide access to:

``design``
   Design object that the design template currently renders.

``content``
   Current content or version in case of a versioned content that is
   rendered using this design template.

``request``
   Zope request object.

``template``
   Refers to your design template (this can be used if you define TAL
   macros in your template, to reuse them in that same template).

The design method ``update`` defined on line 8 will be called before
the design template is rendered. You can override this method in order
to compute any value you will need to render later inside your design
template. For example, you can access the value defined on line 9,
with ``design.title``.

.. note::

   Like for a regular Silva view (see :ref:`creating-a-default-view`),
   you can use both of the directives :py:func:`grok.templatedir` and
   :py:func:`grok.template` to control which design template is
   associated with your design class.

You can specify an icon for your design, and optionally for page
models using your design as well, using the ``silvaconf.icon``
directive:

.. code-block:: python
   :linenos:

   from silva.core import conf as silvaconf

   class MyDesign(Design):
       silvaconf.icon("design.png", model="model.png")


Icons are looked inside your extension directory, like it is done for
Silva content type.

.. _adding-slot-to-your-design:

Adding slot to your design
--------------------------

A design is not really useful unless you define slots to be used with
it (:py:interface:`~silva.core.contentlayout.interfaces.ISlot`). For
this you need to define a variable ``slots`` in your design class:

.. sourcecode:: python
   :linenos:

   slots = {
      'first': Slot(css_class='first-slot'),
      'second': Slot(css_class='second-slot'),
      'footer': Slot(tag='footer')}

After you defined the slots on the design, you can refer to them inside
your design template, with the help of the ``slot:`` expression:

.. sourcecode:: html

   <tal:footer tal:content="structure slot:footer" />

You need to use the modifier ``structure`` in conjunction with
``slot:``, unless you don't want to escape the HTML generated by the
slot.

A slot can take the following options:

``tag``
   HTML tag to use in in the output for the slot container. It must be
   a block-level element in HTML, to ensure that the content layout
   editor works properly. This default to ``div``.

``css_class``
   Optional CSS class to be set on the slot tag.

``restrictions``
   Optional list of restriction objects
   (:py:interface:`~silva.core.contentlayout.itnerfaces.ISlotRestriction`)
   to apply on the blocks contained inside this slot.

.. warning::

   Every slot used inside the template *must be* declared in the
   design. If you remove a slot from a design, you *must* remove it
   from the design, otherwise it won't be detected as not used.


Restricting your design
-----------------------

You can restrict the availability of a design to a given content with
the help of the Grok directive :py:func:`grok.context`:

.. sourcecode:: python
   :linenos:

   from silva.core.contentlayout import Design
   from silva.app.page.interfaces import IPage
   from five import grok

   class MyDesign(Design):
       grok.context(IPage)


- On line 6, we restrict the design to be used only by pages
  implemented the inteface
  :py:interface:`silva.app.page.interfaces.IPage`, that is *Silva
  Page*. Other content type won't be able to use this design.


You can restrict the availability of a design to editors or authors
that have at least a given permission using the Grok directive
:py:func:`grok.require`. For a list of available permissions, you can
refer to the list of Silva default's :ref:`available-permissions`.

.. sourcecode:: python
   :linenos:

   class MyDesign(Design):
       grok.require('silva.ManageSilvaContent')

- On line 2, we restrict the design to editors that have at least the
  permission ``silva.ManageSilvaContent``, that is *Editor*,
  *ChiefEditor* and *Manager*.


Restricting the slot of your design
-----------------------------------

You can use the ``restrictions`` parameters of a slot, with a list of
restriction objects to restrict the blocks that can be added or moved
to your slot.

When a block will be added or moved to a slot, the restriction objects
for the given slot will be consulted, in the order they are specified
in the ``restrictions`` list. The first restriction object to
explicity allow or deny the block in the slot will make the
decision. If no restriction object explicitly allow or deny the block,
the block will be allowed to be added or moved in the slot.

Example:

.. sourcecode:: python
   :linenos:

   from silva.core.interfaces import IImage
   from silva.core.contentlayout import Slot, restrictions

   slots = {
      'content': Slot(restrictions=[
             restrictions.Content(schema=IImage),
             restrictions.BlockAll()]),
      'navigation': Slot(tag='nav', restrictions=[
             restrictions.CodeSourceName(allowed=['cs_toc']),
             restrictions.BlockAll()]),
      'footer': Slot(tag='footer', restrictions=[
             restrictions.Permission(permission='silva.ApproveSilvaContent'),
             restrictions.CodeSourceName(disallowed=['cs_portlet_element'])])
      }

- On line 5 to 7, we define a slot ``content`` that only authorizes
  images to be added to it.

- One line 8 to 10, we define a slot ``navigation`` that only
  authorizes the code source ``cs_toc`` to be added to it.

- Finally, on line 11 to 13, we define a slot ``footer``, where you
  can add everything except the code source ``cs_portlet_element``.


The following restriction objects are available:

.. class:: silva.core.contentlayout.slot.restrictions.Permission

   Restrict the modification of the slot to authors or editors that
   have a least the given ``permission``. Refer to
   :ref:`available-permissions` for a full list of usuable
   permissions.

.. class:: silva.core.contentlayout.slot.restrictions.Content

   Restrict the content that can refered inside the slot, using a
   *Site content* block. The parameter ``schema`` can be used to
   restrict the content using an interface.

.. class:: silva.core.contentlayout.slot.restrictions.CodeSourceName

   Restrict the code sources that can be added inside the slot. Takes
   two sets of identifiers as parameters, ``allowed`` as a whitelist of
   authorized code source identifiers and ``disallowed`` as a
   blacklist of code source identifiers.

.. class:: silva.core.contentlayout.slot.restictions.BlockAll

   Prevent any block that was not explicitly authorized before this
   restriction object to be added inside the slot.


For more information about slots, please refer to
:ref:`adding-slot-to-your-design`.


Modifying your layout when your design is used
----------------------------------------------

You can modify your Silva :term:`layout` when your design is used on a
page, in order to let it control more space in your HTML page.

For this you can define a customization marker, and an alternate
layout template that will render fewer :term:`Content Provider`,
letting this responsability to your design template.

You can add your marker to the list of markers managed by your design,
and it will be automatically applied on the page when your design is
selected, and removed when your design is changed for an another.

Example:

.. code-block:: python
   :linenos:

   from silva.core.contentlayout import Design
   from silva.core.layout.interfaces import ICustomizableTag
   form silva.core.views import views as silvaviews
   from silva.app.page.interfaces import IPage
   from five import grok

   class IMyDesignCustomization(ICustomizableTag)
       """Custom layout for pages using my design.
       """
       grok.context(IPage)


   class MyDesignBody(silvaviews.ContentProvider):
       """Content provider that overrides the body content
       provider when the customization marker is applied.
       """
       grok.context(IMyDesignCustomization)
       grok.name('body')


   class MyDesign(Design):
       grok.context(IPage)
       grok.name('mydesign_customized')
       grok.title('My design (customize the layout)')

       markers = [IMyDesignCustomization]

       ...


- On line 7 to 10, we defined a new customization markers, that is
  only usuable by :py:interface:`~silva.app.page.interfaces.IPage`.

- On line 13 to 18, we define a new content provider for our new
  marker, that will override the content provide ``body`` used by the
  layout (if your layout is based on Porto). With this content
  provider, you will have to define a new template that will render
  less elements than your default layout.

- On line 26, we add our customization marker to the list of
  customization markers managed by your design.

.. warning::

   The layout modification can still be applied when an error, or a
   regular Silva views :term:`page` is rendered.

.. _Chameleon Page Template: http://chameleon.repoze.org/docs/latest/
